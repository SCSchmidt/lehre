---
title: "rausgeschmissen"
author: "Sophie C. Schmidt"
date: "14 7 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Ordinale Daten
### K-S-Test

Der K-S-Test benötigt mindestens ordinal skalierte Daten, man kann ihn als Anpassungstest verwenden (und damit den Datensatz auf normalverteilung testen) und als Zweichstichproben-Test nutzen.


Zuerst als Anpassungstest. Nehmen wir eine ordinale Variable, ... und stellen wir fest, dass wir in dem Pinguin-Datensatz keine ordinale Variable haben. Nagut. Dann erstellen wir aus dem metrischen Datensatz "flipper_length_mm" eine ordinale Variable, in dem wir die Daten klassizieren.

#### Exkurs: Klassifikation von Daten in R



Als erste erstellen wir einen neue Spalte in unserem Chinstrap-Pinguin-Datensatz, in dem wir die Klassen dann ablegen werden. Das ist super einfach, wir sagen einfach "hier liegt jetzt überall `NA`": 

```{r}
chinstraps$class_flipper_length <- NA
```

Wenn ihr euch den Datensatz jetzt anschaut, ist eine neue Spalte "class_flipper_length" entstanden, in der nur NA steht.

Jezt müssen wir entscheiden, wie wir die Klassen aufteilen. Für das Anlegen von Klassen gibt es sogar ein paar sinnvolle Regeln!

 - Klassen müssen eindeutig definiert sein und sich gegenseitig ausschließen, d. h. es darf keine Überlappungen geben.
 - Klassen müssen erschöpfend sein, also alle möglichen Ausprägungen des Wertes erfassen. Kein Wert darf außerhalb einer Klasse bleiben.
 - Klassen sollten gleich breite Intervalle bilden. Häufig werden runde Werte als Mitte oder Grenzen der Klasse definiert. Computergestützte Klassenbildung bieten noch unterschiedliche rechnerische Verfahren, in denen z. B. die Klassengrenzen dort gesetzt werden, wo besonders wenig Werte liegen. 
 - Offene Klassen („weniger als...” oder „mehr als...”) sollten vermieden werden, da mit ihnen nicht mehr gerechnet werden kann. Das bedeutet, dass immer Unter- und Obergrenzen angegeben werden sollten. Aus ihnen lassen sich mittlere Werte errechnen, mit denen weitergearbeitet werden kann.
 - Als Faustregel für die Anzahl der Klassen finden sich folgende Tips: 2*k < n , wobei n die Anzahl der Werte beschreibt und k die Anzahl der Klassen. Anders ausgedrückt: Es sollte weniger als halb so viele Klassen wie aufgenommene Werte geben. Eine andere Faustregel besagt, die Anzahl der Klassen möge die Quadratwurzel aus der Stichprobengröße sein: $$k = \sqrt{n}.$$ Logisch ist, je weniger Klassen gewählt werden, desto breiter sind sie.

In welchem Bereich müssen die Klassen denn angelegt werden? Was genau ist der größte und der kleinste Wert?

```{r}
range(chinstraps$flipper_length_mm)
```

Wir brauchen also Klassen von 178 bis 212 mm. 

Man könnte also 4 Klassen bestimmen, die in 10er Schritten vorangehen. 176-185, 186-195, 196-205, 206-215. Tun wir das doch einmal. Wir nehmen die `cut`-Funktion, die genau dafür gemacht wurde. Wir "zerschneiden" den Datensatz an den angegebenen Zahlen. Das Ergebnis wird einer Variablen zugewiesen, die wir dann in unseren Datensatz in die Spalte `chinstraps$class_flipper_length` zuweisen können. 

```{r}
# zerschneiden des Datensatzes chinstraps$flipper_length_mm an den angegebenen Stellen, als Labels geben wir die Klassengröße an
groups <- cut(chinstraps$flipper_length_mm, 
              c(175,185, 195, 205, 215), # "Schnittstellen"
              labels = c("176-185", "186-195", "196-205", "206-215")) 

# der Spalte in dem Datensatz zuweisen
chinstraps$class_flipper_length <- as.factor(groups)
```

So. Jetzt haben wir einen Datensatz, der zwar als `factor` abgespeichert ist, dessen `levels` jedoch in einer sinnvollen Ordnung vorliegen: `r levels(chinstraps$class_flipper_length)`

Schauen wir doch jetzt endlich, ob diese Klassen sich mit der Normalverteilung vergleichen lassen!

Als erstes Zählen wir aus, wie viele Pinguine in welcher Klasse liegen:

```{r}


per <- table(chinstraps$class_flipper_length) # dann zähl ich die Häufigkeiten

ks.test(per, "pnorm" ) # und vergleiche die Häufigkeiten mit der Normalverteilung "pnorm"
```
Der p-Wert ist sehr sehr klein, das heißt? 

Daran denken: Die Nullhypothese ist, dass die beiden Verteilungen gleich sind. Wir testen in die "andere Richtung", wenn p > 0.05 sind die Daten normalverteilt.

Schauen wir uns doch die Daten noch einmal kurz an, um zu überprüfen, ob wir das richtig verstanden haben:

```{r optische überprüfung}
barplot(per) # das ist der base-R-Befehl um ein Säulendiagramm zu erstellen. Nicht schön, aber schnell und wenig zu tippen. 
```

Alles klar?

Dann weiter mit 




## Exkurs: nested (verschachtelt) und crossed (gekreuzte) Modelle

Bei der Auswahl, welchen Test man anwenden möchte, ist es wichtig zu wissen, wie die Daten strukturiert sind. Wenn ich zwei verschiedene Faktoren (z. B. Spezies und Insel) betrachte, gibt es folgende Möglichkeiten:

1. Alle Pinguine einer Art kommen je genau auf nur einer Insel vor.
2. Pinguine jeder Art kommen auf allen Inseln vor.
3. Es gibt Inseln, auf denen kommen nur Pinguine einer Art vor und es gibt Inseln, auf denen kommen mehrere Arten vor.
4. Alle Pinguinarten leben nur auf einer Insel. 
5. Alle Pinguine wurden von Seelöwen gefressen (quatsch).

Der erste Fall, Pinguine einer Art kommen nur auf je einer Insel vor, wird als verschachtelt (engl. nested) bezeichnet. Es bedeutet, dass ein Faktor-Wert (zB Gentoo-Pinguin) nur in einem bestimmten Wert des anderen 
Faktors (zB Insel Biscoe) vorkommt. Damit haben wir keine gleichmäßige Verteilung der Kategorien mehr und wenn wir die Daten tabellarisch zusammenfassen, wie wir es hier getan haben, entstehen diese 0-Felder.

Der zweite Fall: Alle Pinguinarten kommen auf allen Inseln vor, ist das perfekte Beispiel eines gekreuzten (crossed) Modells. Das heißt ich habe in der Kreuztabelle in jedem Feld mindestens eine 1.

Manchmal gibt es Mischformen und das haben wir hier: Chinstrap- und Gentoo-Pinguine kommen nur auf jeweils einer Insel vor und Adelie-Pinguine hüpfen überall herum. 

Weil dem so ist, können wir den Chi-Quadrat-Test nicht machen. Er funktioniert nur, wenn die Faktoren gekreuzt sind.

Eine sehr ausführliche Erklärung des damit zusammenhängenden Codierungsproblems gibt es z. B. hier <https://qastack.com.de/stats/228800/crossed-vs-nested-random-effects-how-do-they-differ-and-how-are-they-specified>
