---
title: "Basics und mehr"
author:
  - Schmidt, Sophie C.
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    bookdown::word_document2:
      fig_caption: yes
      reference_docx: "../templates/template.docx" # Insert path for the DOCX file
bibliography: references.bib
csl: "../templates/journal-of-archaeological-science.csl" # Insert path for the bib-style
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = TRUE,
  comment = "#>",
  fig.path = "../figures/",
  fig.width=10, 
  fig.height=10
)
```


```{r Pakete und Daten laden}
library(archdata)
library(ggplot2)

#brauchen wir später, drum installiert es doch gleich am Anfang.
library(tidyr)
library(dplyr)
```

Die Informationen, die jetzt aufploppen "Attaching package", "objects are masked" etc brauchen uns nicht zu interessieren. Hier geht es um Paketabhängigkeiten und -überlagerungen.

## ggplot- Logik!

ggplot2 ist ein Paket, dase von Hadley Wickham entwickelt wurde, und viele Funktionen zur Visualisierung von Daten bietet (für eine Übersicht und Inspirationen siehe z. B: http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html und https://www.r-graph-gallery.com/). Es folgt einer eigenen Logik, der "Grammatik der Diagramme" und gehört zum Tidyverse. Grundlegend ist eine Art "Layer-Konzept", dass ich mit jeder weiteren Zeile Code ein neues Layer zu dem Diagramm hinzufüge, wie bei der Bildbearbeitung mit Photoshop oder Gimp.

Erarbeiten wir uns das Schritt für Schritt.

3 Dinge gibt es in jedem ggplot, die definiert werden müssen:

- Welche Daten es benutzen soll ggplot(data = ), 

- welche Art von Diagramm es bauen soll (geom) und 

- wie das Diagramm aussehen soll (aes() von aesthetics), damit überhaupt etwas entsteht, also z. B., was auf der x- und der y-Achse abgetragen werden soll.

Alles andere danach sind reine Verschönerungsmaßnahmen. Mit "scales" lassen sich die Achsen und Legenden verändern, mit "theme" Hintergrundfarbe u. ä. (für mehr Infos siehe:  https://r-intro.tadaa-data.de/book/visualisierung.html )

Nehmen wir uns ein Beispiel vor und erarbeiten es uns der Reihe nach.


## Ein Säulen- oder Balkendiagramm
Ein Säulendiagramm eignet sich zur Darstellung nominaler und ordinaler Variablen. Ihr könnt es ja mal mit metrischen probieren, dann seht ihr schnell, warum das nicht gut ist.

Als erstes müssen wir das Paket ggplot2 installieren (*install.packages*) und aufrufen:

```{r}
library(ggplot2)
```

Dann bauen wir ein erstes einfaches Säulendiagramm. Der Befehl für diese Art des Diagramms ist `geom_bar`. 

Die Information `data = ` kann entweder direkt in die runden Klammern hinter `ggplot()` geschrieben werden ODER dem `geom_` hinzugefügt. 

Wie aber soll das Säulendiagramm (`geom_bar`) aussehen, welche Spalte des Datensatzes soll genau wie dargestellt werden? Das ist die Information die in `aes()` eingegeben werden muss.

Wir möchten jetzt also ein Säulendiagramm bauen, dass auf der x-Achse die verschiedenen Spezies des penguin-Datensatzes und die Häufigkeiten (wie viele Datensätze aus den verschiedenen Spezies gibt es) auf der y-Achse zeigt:

```{r}
ggplot()+ 
  geom_bar(data = penguins, aes(x = species)) 
```

Das + am Ende jeder Zeile sagt R, dass der Befehl in der nächsten Zeile weiter geht, ähnlich wie bei der pipe. 

Das ist doch schonmal was. Die Information die wir wollen, wird schnell und einfach angezeigt. 

Aber schön ist es noch nicht.

Geben wir den Achsen eine andere Beschriftung. Mit dem "labs"-Befehl lassen sich die Achsenbeschriftungen und die Überschriften ändern:
```{r erstes Säulendiagramm mit Achsen-Titel}
ggplot()+ 
  geom_bar(data = penguins, aes(x = species))+ 
  labs(y = "Anzahl",
       title = "Anzahl Tiere pro Spezies")
```

Wir können auch die Säulen bunt einfärben. Der Befehl *fill* gibt den Balken unterschiedliche Farben, je nach den Angaben in der Spalte, die ich spezifiziere (hier wieder Spezies):

```{r erstes Säulendiagramm und jetzt bunt!}
ggplot()+ 
  geom_bar(data = penguins, aes(x = species, fill = species))+ 
  labs(y = "Anzahl",
       title = "Anzahl Tiere pro Spezies")

```

Vielleicht nervt euch auch, so wie mich, dass die Reihenfolge der Balken nicht nach Größe geordnet ist?

Ändern wir das doch einmal! 

Leider bedeutet das in R, dass wir unseren Datensatz ändern müssen. Da R bei geom_bar während der Diagrammerstellung erst die Häufigkeiten zählt, kann er im Vorhinein nicht die Reihenfolge nach den Häufigkeiten sortieren.

Also müssen wir R helfen und erst die Häufigkeiten auszählen und ihm dann einen neuen Befehl geben.

### Exkurs: Pivot-Tabelle

Für das Zählen von Häufigkeiten gibt es einen einfachen Befehl, der einer pivot-Table in Excel entspricht, falls jemand das kennt. Ich wähle ein oder zwei Variablen aus, deren Zusammenhänge ausgezählt werden, also wie häufig kommen sie gemeinsam vor / bzw wie häufig kommt die eine Variable vor. Der Befehl heißt (echt simpel) `table`.

```{r}
table(penguins$species)
```

Der Output ist klar, aber um damit arbeiten zu können, müssen wir die Tabelle speichern:


```{r}
species <- table(penguins$species)
```

Dummerweise ist das jetzt ein bestimmtes Datenformat, das ggplot nicht mag, schaut mal welches:

```{r}
class(species)
```

ggplot arbeitet am besten mit dataframes. Darum wandeln wir species noch einmal in einen Dataframe um. Das geht einfach mit der Funktion `as.data.frame` und damit überschreiben wir die alte table:

```{r}
species  <- as.data.frame(species)
```

Schaut euch species jetzt einmal an:

```{r}
View(species)
```
Wie ihr seht, gibt es jetzt die Spalte "Var1" und die Spalte "Freq". Wir hatten R nicht gesagt, wie es die Spalten der neue Tabelle benennen sollte. Das holen wir jetzt nach. Nennen wir doch die erste Spalte "species" und die zweite "n". "n" ist eine typische Bezeichnung für Häufigkeiten in der Statistik.

```{r}
colnames(species)  <- c("species", "n")
```

Das waren ganz schön viele Zeilen Code. Wir können das auch alles in einer Zeile machen und die Aufgaben "verschachteln":

```{r}
species <- as.data.frame(table(penguins$species, dnn = list("species")), responseName = "n")
```
`as.data.frame` ist die "äußerste" Funktion, wird also als letztes ausgeführt, darin liegt `table`, welches auf unsere Daten "penguin$species" angewandt wird, mit den Argumenten `dnn = list("species")`. Innerhalb des as.data.frame-Befehls wird  `responseName = "n"` gesetzt, um die Spalten richtig zu benennen.

Beide Wege führen zu dem Ergebnis, das wir haben wollen. Am Anfang schreibt man meist alles ausführlich aus, aber mit der Zeit fängt man an, kürzer und verschachtelter zu schreiben, weil einem das Lesen des Codes leichter fällt. Macht das, wie ihr wollt!

### x nach Häufigkeiten sortieren

Jetzt können wir endlich die Daten wieder visualisieren. Aber Achtung, wenn wir ggplot nicht selber die Häufigkeiten auszählen lassen wollen, sondern sie ihm "an die Hand geben", nehmen wir nicht `geom_bar` sondern `geom_col` und spezifizieren mit y die Höhe des Balkens.
```{r}
ggplot()+ 
  geom_col(data = species, aes(x = species, y = n, fill = species))+ 
  labs(y = "Anzahl",
       title = "Anzahl Tiere pro Spezies")
```

"Aber ey!" werdet ihr sagen. Die Balken sind ja noch nicht in der richtigen Reihenfolge. Richtig. Aber jetzt können wir das machen, in dem wir eine ganz kleine Änderung einfügen: Wir ordnen x um, englisch "reorder". 

```{r}
ggplot()+ 
  geom_col(data = species, aes(x = reorder(species, n), y = n, fill = species))+ 
  labs(y = "Anzahl",
       title = "Anzahl Tiere pro Spezies")
```
Die Ansage ist: Nimm als x species, aber geordnet nach der Größe von n. 
Jetzt ist aber die Bezeichnung von der X-Achse wieder hässlich (nämlich der Code, den wir da eingegeben hatten). Also fügen wir noch eine Zeile hinzu:

```{r}
ggplot()+ 
  geom_col(data = species, aes(x = reorder(species, n), y = n, fill = species))+ 
  labs(y = "Anzahl",
       x = "Spezies",
       title = "Anzahl Tiere pro Spezies")
```

Wunderbar. 

### Beschriftungen

Jetzt gefällt mir aber nicht, das die Beschriftung so klein ist. Ändern wir das doch einmal. Beschriftungsgröße ist etwas, das zu den "Verschönerungsoptionen" gehört und in einem "theme" abgehandelt wird. Wir öffnen also ein "theme", spezifizieren darin, dass wir über die beiden Achsen-Titel reden wollen (axis.title) und die Elemente des Textes ändern (element_text). Wir können dort angeben, dass der Text dickgedruckt werden soll (face = "bold") und die Größe (size = 20). Dann machen wir doch das gleiche noch mit der Beschriftung der Werte auf den Achsen (axis.text). Hier ändern wir vllt nur die Größe. Und am Ende noch den Titel von dem ganzen

```{r}
ggplot()+ 
  geom_col(data = species, aes(x = reorder(species, n), y = n, fill = species))+ 
  labs(y = "Anzahl",
       x = "Spezies",
       title = "Anzahl Tiere pro Spezies")+
  theme(axis.title = element_text(face="bold", size=20),
        axis.text  = element_text(size=16),
        title = element_text(size = 25))
```

Herzlichen Glückwunsch! Das sieht doch langsam nach einer publizierbaren Grafik aus.

### und in ein Balkendiagramm ändern.

Wenn wir der Meinung sind, wir hätten lieber ein Balkendigramm, dann können wir das ganze einfach um 90 Grad kippen. Der Befehl heißt `coord_flip()` und wird einfach mit einem + unten dran gehängt:

```{r}
ggplot()+ 
  geom_col(data = species, aes(x = reorder(species, n), y = n, fill = species))+ 
  labs(y = "Anzahl",
       x = "Spezies",
       title = "Anzahl Tiere pro Spezies")+
  theme(axis.title = element_text(face="bold", size=20),
        axis.text  = element_text(size=16),
        title = element_text(size = 25))+
  coord_flip()
      
```




## Dichtediagramme!

Wie die funktionieren, habt ihr hoffentlich  gelesen.


Bei Dichtediagrammen wird die x-Achse wieder metrisch. Das geht also NICHT mit den Periodenangaben, mit denen wir die ganze Zeit eben rumgespielt haben. 

Wir könne stattdessen wieder mit den Bronzezeitlichen Tassen arbeiten.

Die Funktion in R heißt density.
```{r dichte}
ggplot(data = BACups)+
  geom_density(aes(x = RD))
  
```
Das war doch ganz einfach. Aber jetzt möchte ich gern die unterschiedlichen Messungen an den Tassen im Vergleich sehen.

```{r density mehrere, fig.height= 8, fig.width = 8}
# Ich kann ganz einfach den geom_density-Befehl mehrmals rufen

ggplot(data = BACups)+
  geom_density(aes(x = RD, col ="Randdurchmesser"))+
  geom_density(aes(x = ND, col = "Nackendurchmesser"))+
  geom_density(aes(x = SD, col = "Schulterdurchmesser"))

```
Das funktioniert zwar, aber es ist nicht gerade "elegant".

Elegant wär es, erst die Daten so umzuformen, dass sich in ggplot dann mit möglichst wenig Befehlen meine Grafik darstellen lassen kann.

Wir brauchen also wieder die Umformungen mit tidyr. Der Schritt ist relativ einfach. Ich nehm die Spalten, die mich interessieren sortiere die Werte dieser Spalten neu, so dass ich eine Spalte habe, in der steht die ehemalige Überschrift der Spalte und einen Spalte, in der der dazugehörige Wert steht. Das ist wieder der gather-Befehl.

```{r density daten tidy, fig.height= 8, fig.width = 8}

BACups%>%
  gather(key = "Durchmesser", value = "Wert", "RD", "ND","SD") %>%
  ggplot()+
  geom_density(aes(x = Wert, col= Durchmesser))

# genauso viele Zeilen Code aber schicker.
```


## Metrische Daten

In der letzten Stunde haben wir vor allem mit nominalen Daten gearbeitet und sie dargestellt. Dafür eignen sich Balkendiagramme ganz hervorragend. Heute geht es aber um metrische Daten.

Deshalb lernen wir ein paar neue Diagramme kennen.

- Streudiagramme

- Histogramme

- Boxplot-Diagramme 


Aber zuerst die Daten laden:
```{r Daten laden}
#install.packages("ggplot2")
library(archdata)
data("BACups")
data("Snodgrass")
library(ggplot2)

```


# Histogramm

Fangen wir an mit Histogrammen. Histogramme sind sehr beliebt für metrische Daten, weil man relativ einfach die Verteilung der Werte erkennen kann. Ein Histogramm sieht manchmal aus wie ein Balkendiagramm, ist es aber nicht! Histogramme haben auf der x-Achse eine klassifizierte metrische Variable und auf der y-Achse entweder die Häufigkeit dieses Wertes oder die Dichte. 

Ein Beispiel:

```{r Histogramm}
ggplot(data = BACups)+
  geom_histogram(aes(x = RD))
```

Wenn ihr das ausgeführt habt, sollte eine Meldung aufgeploppt sein: "`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."

"Binwidth" bezeichnet die Größe der Klasse. "bins = 30" heißt, dass der gesamte Datensatz in 30 gleich große Klassen unterteilt wurde.

Probiert einmal verschiedene Werte in dem Beispiel aus:

```{r}
ggplot(data = BACups)+
  geom_histogram(aes(x = RD), binwidth = 5) # Klassengröße 5. Versucht doch einmal andere Werte und schaut, was passiert!
```

Was lernen wir daraus?
Die Wahl der Klassengröße macht eine Menge aus, wie ich die Daten wahrnehme und welche Aussagen ich über sie treffen werde. 

Was gibt es noch für Möglichkeiten der Datenvisualisierung?

# Streudiagramme

Bei Streudiagrammen kann ich zwei Variablen einer Einheit gegeneinander plotten.

Wir tragen auf der X- und auf der Y-Achse metrische Daten ab. Das gehört zu den aesthetics-Elementen, deshalb tun wir die Info in die Klammern hinter aes(): 

```{r Streudiagramm basics}

ggplot(data = BACups)+
  geom_point(aes(x = RD, y = ND))

```

Jetzt können wir damit wieder die Dinge tun, die wir mit dem Balkendiagramm gemacht hatten, also die Achsen beschriften, einen Titel vergeben und den Style ändern:

```{r Streudiagramm mit Titel, mit x- und y-Achsenbeschriftung}
ggplot(data = BACups)+
  geom_point(aes(x = RD, y = ND)) + 
  labs(x =" Randdurchmesser",
       y ="Nackendurchmesser",
       title = "Rand- und Nackendurchmesserim Verhältnis zueinander")+
  theme_bw()

```

Was kann man noch tolles machen? Die Form der Punkte von einer Variablen bestimmen lassen! 
Und die Farbe! 

Welches Merkmal, das ich in der Tabelle als Spalte aufgenommen habe die Form der Punkte bestimmt lege ich mit "shape" fest, die Farbe mit "color".


```{r Streudiagramm mit schönen Punkten, fig.height=5, fig.width=5}

ggplot(data = BACups)+
  geom_point(aes(x = H, y = SD, shape = Phase, color = Phase)) + 
  labs(x =" Höhe des Gefäßes",
       y ="Schulterdurchmesser",
       title = "Höhe des Gefäßes im Verhältnis zum Schulterdurchmesser")+
  theme_bw()

```

Oooooh, schaut euch mal das Ergebnis an! 
Da könnte man schon fast was interpretieren! 

Probiert doch einmal noch 2-3 andere Parameter aus, ob die vielleicht auch einen Unterschied zwischen den zwei Phasen erkennen lassen?



Form und Farbe kann man natürlich auch von unterschiedlichen Parametern bestimmen lassen. Da diese Eigenschaften jedoch nominaler Art sein müssen und wir keinen zweiten nominale Variable in dem BACups-Datensatz haben, benutzen wir doch mal einen anderen.

```{r Streudiagramm mit anderem Bsp, fig.height=5, fig.width=5}
data("Snodgrass")


ggplot(data = Snodgrass)+
  geom_point(aes(x = Width, y = Length, shape = Segment, color = Inside))+ 
  labs(x =" Breite des Hauses",
       y ="Länge des Hauses",
       title = "Häuser in Snodgrass")+
  theme_bw()

```

Hmmmhh, interessant. Aber ich vermute, der normale Leser des Diagramms kann nicht erkennen, was "Inside" für eine Information beinhaltet.
Kann man vllt die Beschriftung der Legende ändern?

Man kann!!

```{r Streudiagramm Legendenbeschriftung, fig.height=5, fig.width=5}

ggplot(data = Snodgrass)+
  geom_point(aes(x = Width, y = Length, shape = Segment, color = Inside))+ 
  labs(x =" Breite des Hauses",
       y ="Länge des Hauses",
       title = "Häuser in Snodgrass")+
  theme_bw()+
 scale_colour_discrete(name  ="Innerhalb der Mauer oder nicht",
                            breaks=c("Inside","Outside"),
                            labels=c("innerhalb", "außerhalb")) +
    scale_shape_discrete(name  ="Grabungsareal",
                           breaks=c("1","2","3"),
                           labels=c("Areal 1", "Areal 2", "Areal 3"))
```
Was beudetet das alles?

Mit scale_colour_discrete kann ich Legenden (scales) verändern, die mit "color" innerhalb des aesthetics-Bereichs meines Codes für die Graphik definiert werden und die DISKRET sind (also v.a. nominale / ordinale Daten).

Hier benenne ich den Legendentitel mit "Name = " um.

"breaks" bezeichnet die Werte in meiner Spalte, die dann mit den "labels" in der nächsten Zeile umbenannt werden.

Das gleiche kann ich mit der Legende für die FORM der Punkte machen: scale_shape_discrete.

Voll gut! Dann lernen wir doch noch andere Visualisierungsmöglichkeiten kennen.

# Boxplot

![Aufbau eines Boxplotdiagramms](Schier_Boxplottdiagramm.png)

- Q1 = 1. Quartil. Bis hier liegen die ersten 25% meiner Werte, wenn ich sie aufsteigend sortiere
- (Q2 =) Median, den kennen wir schon. Bis hier liegen 50 % meiner Werte, wenn ich sie aufsteigend sortiere
- Q3 = 3. Quartil, bis hier liegen 75% meiner Werte, wenn ich sie aufsteigend sortiere
- Q3 - Q1 ist der Quartilsabstand: In diesem Bereich um den Median herum liegen 50% der "mittleren" Werte. Er wird durch die Box gekennzeichnet
- Bartenden sind das 1,5fache des Quartilsabstandes vom Median aus gerechnet (oder am Ende der Verteilung)
- Extreme liegen außerhalb der Bartenden
- Ausreißer sind mehr als das 3fache des Quartilsabstandes vom Median entfernt



```{r, out.width='25%', fig.align='center', fig.cap='...'}
knitr::include_graphics('Schier_Boxplottdiagramm.png')
```

Ein Boxplottdiagramm eignet sich sehr gut, um mehrere Verteilungen EINER Variablen zu vergleichen. Also mehrere Gruppen in meinem Datensatz, aber immer die gleiche Variable. 

Ein Beispiel:

```{r ein Boxplotdiagramm, fig.height=5, fig.width=5}

ggplot(data = BACups)+
  geom_boxplot(aes(x = Phase, y = ND)) + 
  labs(x ="Phasen",
       y ="Nackendurchmesser",
       title = "Die Nackendurchmesser der zwei Phasen im Vergleich")+
  theme_bw()

```
Ich kann gut erkennen, dass die subappeninen Nackendurchmesser größer sind als die der Protoappeninen Phase.
Yay!

Und jetzt noch einmal für Daten aus Snodgrass: 

```{r mehrere Boxplots, fig.height=5, fig.width=5}
ggplot(data = Snodgrass)+
  geom_boxplot(aes(x = Segment, y = Length, fill = Inside))+ 
  labs(x ="Grabungsareale",
       y ="Länge des Hauses",
       title = "Häuser in Snodgrass")+
  theme_bw()+
   scale_fill_discrete(name  ="Innerhalb der Mauer oder nicht",
                            breaks=c("Inside","Outside"),
                            labels=c("innerhalb", "außerhalb")) 

```
Das kann man doch zur Interpretataion nutzen, nicht wahr?! 


# Bilder sichern

Jetzt haben wir die Bilder bisher nur in R erstellt, wir haben sie noch nicht sinnvoll abgespeichert.

Das ist ganz einfach.

Den _letzten_ Plot, den wir erstellt haben, können wir mit diesem Code speichern:

```{r Bild speichern}
ggsave("Plotname.png", width = 4, height = 4, units = "cm", dpi = 300)
```
Wir geben den Namen den die Datei haben soll (das kann auch ein Pfad werden, damit es in einem bestimmten Ordner gespeichert wird), wir geben mit der Endung das Dateiformat udn sagen mit width und height wie groß das Bild in units = cm abgespeichert werden soll. Außerdem die Auflösung mit dpi. Super praktisch!

(D. h. ich hab das Bild als png in einer Größe von 4x4cm abgespeichert. Es hat eine Auflösung von 300 dpi und liegt in dem gleichen Ordner wie mein Rmarkdown-Dokument, weil ich keinen Pfad angegeben habe)



# Letzte Hinweise ggplot
GGplot hat noch viel viel mehr Möglichkeiten. Um einen Überblick zu bekommen, empfehle ich den Blogpost hier zu lesen, der vorführt, wie sich so eine Visualisierung entwickeln kann und am Ende richtig richtig gut aussieht:
https://cedricscherer.netlify.com/2019/05/17/the-evolution-of-a-ggplot-ep.-1/

Hilfen, um mit R und ggplot zurechtzukommen sind: 

- die Schummelzettel: https://www.rstudio.com/wp-content/uploads/2015/06/ggplot2-german.pdf 

- dieses R-Intro-Buch: https://r-intro.tadaa-data.de/book/visualisierung.html

- das deutsche Wikibook zu R: https://de.wikibooks.org/wiki/GNU_R und 

- das englische R-Cookbook: http://www.cookbook-r.com/ 

Das Nachschlagewerk für RMarkdown:
- The Definitive Guide: https://bookdown.org/yihui/rmarkdown/

- offizielle website: https://rmarkdown.rstudio.com/index.html


